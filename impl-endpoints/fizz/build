#!/bin/bash
#
# Invoked by scripts/build_images.sh. We must output a valid container ID to
# stdout at the end of the script.


# Real stdout is fd 100 to prevent accidental echos
exec 100>&1
exec 1>&2


THIS_DIR="$(dirname "$(readlink -f "$0")")"
cd "$THIS_DIR"

require_env_var() {
    [ -z "${!1:-}" ] && { echo "Missing required env var $1"; exit 2; }
    return 0
}

verify_src_dir() {
    [ ! -d "$1/folly" ] && { echo "Missing folly in src directory"; exit 1; }
    [ ! -d "$1/fizz" ] && { echo "Missing folly in src directory"; exit 1; }
    return 0
}
# This would be trivial to do with `buildah`, but since I'm assuming only docker
# we have to do it the crappy way.
#
# 1) Build the fizz binary inside of the fizz buildroot.
# 2) Copy fizz and its dependencies into the final image

set -uexo pipefail

require_env_var FIZZBUILD_CCACHE_DIR
require_env_var FIZZBUILD_BUILD_DIR
require_env_var FIZZBUILD_SRC_DIR

verify_src_dir "$FIZZBUILD_SRC_DIR"

if [ -z "${FIZZBUILD_SKIP_BUILD_BUILDROOT:-}" ]; then
    docker build --target fizz.buildroot builder/ -t fizz.buildroot
    docker build --target fizz.runtime builder/ -t fizz.runtime
fi

docker run \
    -v "$FIZZBUILD_CCACHE_DIR:/ccache" \
    -v "$FIZZBUILD_BUILD_DIR:/build" \
    -v "$FIZZBUILD_SRC_DIR:/src" \
    fizz.buildroot \
    fizz-build

tmpcontainer="$(mktemp)"
rm -f "$tmpcontainer"
docker run --cidfile "$tmpcontainer" -v "$FIZZBUILD_BUILD_DIR:/build" fizz.runtime cp /build/fizz/bin/fizz /usr/local/bin/fizz
tmpcontainerid="$(cat "$tmpcontainer")"

finalimg="$(docker commit -c 'CMD "bash"' -c 'ENTRYPOINT /run_endpoint.sh' "$tmpcontainerid")"
docker rm -f "$tmpcontainerid"
echo "$finalimg" >&100
